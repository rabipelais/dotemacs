#+TITLE: Sebas Emacs configuration
#+OPTIONS: toc:4 h:4
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle init.el
#+PROPERTY: tangle init.el

* About this file
   :PROPERTIES:
   :CUSTOM_ID: babel-init
   :END:
<<babel-init>>

This is my attempt at making a literate Emacs config file.
To actually produce/extract the elisp code, run =M-x org-babel-tangle= (=C-c C-v t=).

* Meta

All changes to the configuration should be done in =init.org=, *not* in
=init.el=. Any changes in the =init.el= will be overwritten by saving
=init.org=. The =init.el= in this repo should not be tracked by git, and
is replaced the first time Emacs is started (assuming it has been renamed
to =~/.emacs.d=).

Emacs can't load =.org=-files directly, but =org-mode= provides functions
to extract the code blocks and write them to a file. There are multiple
ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
could just use =org-babel-load-file=, but I had problems with
byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
but the git commits got a little messy. So here is a new approach.

When this configuration is loaded for the first time, the =init.el= is
the file that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
;; This file replaces itself with the actual configuration at first run.

;; We can't tangle without org!
(require 'org)
;; Open the configuration
(find-file (concat user-emacs-directory "init.org"))
;; tangle it
(org-babel-tangle)
;; load it
(load-file (concat user-emacs-directory "init.el"))
;; finally byte-compile it
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

It tangles the org-file, so that this file is overwritten with the actual
configuration.

There is no reason to track the =init.el= that is generated; by running
the following command =git= will not bother tracking it:

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If one wishes to make changes to the repo-version of =init.el= start
tracking again with:

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

The =init.el= should (after the first run) mirror the source blocks in
the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
extracts the code blocks from the current file into a source-specific
file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to
the =after-save-hook= ensuring to always tangle and byte-compile the
=org=-document after changes.

#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "If the current buffer is 'init.org' the code-blocks are
tangled, and the tangled file is compiled."
  (when (equal (buffer-file-name)
               (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle)
      (byte-compile-file (concat user-emacs-directory "init.el")))))

(add-hook 'after-save-hook 'tangle-init)
#+END_SRC
* External dependencies
To be able to use some of the funtions in this configuration, you need some external dependencies:

- The Fira Code font
- Rust compiler
- Racer
- All-the-icons fonts

Other mode and language specific dependencies are more obvious and described in their respective sections

** Fira Code
Can be downloaded from here: [[https://github.com/tonsky/FiraCode][github repository]]. To support ligatures, you may also need the extended Symbol codepoints, which can be downloaded from [[https://github.com/tonsky/FiraCode/files/412440/FiraCode-Regular-Symbol.zip][here.]]

** Rust
To install Rust simply follow the instructions on [[https://www.rust-lang.org/tools/install][this page.]]

** Racer
Using =cargo= run =cargo +nightly install racer=

** All-the-icons fonts
Make sure the =all-the-icons= package is loaded and then run =M-x all-the-icons-install-fonts=. Restarting emacs may be required.
If it starts lagging like an absolute sloth or is showing wrong symbols, be sure =(setq inhibit-compacting-font-cache t)= is evaluated (it is in this config).
To test if the icons work, you can run =(all-the-icons-insert-icons-for 'alltheicon)= (warning: them's a lot of icons).


(TODO: make emacs not error out sometimes if Racer or Rust are not present)

* General Configuration
** Startup

#+BEGIN_SRC emacs-lisp

;; Without this, my emacs version doesn't work, will probably break somithing
(defconst debian-emacs-flavor 'emacs26
   "A symbol representing the particular debian flavor of emacs running.
 Something like 'emacs20, 'xemacs20, etc.")

  (require 'package)

  ;; Add melpa
  (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                      (not (gnutls-available-p))))
         (proto (if no-ssl "http" "https")))
    ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
    ;;(add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
    (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
    (when (< emacs-major-version 24)
      ;; For important compatibility libraries like cl-lib
      (add-to-list 'package-archives '("gnu" . (concat proto "://elpa.gnu.org/packages/")))))

  (package-initialize)
#+END_SRC

Install, start up and configure =use-package=, really useful for loading packages lazily

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(setq use-package-always-ensure t)
(setq use-package-always-defer t)
(setq use-package-verbose t)
(setq use-package-always-ensure t)
(require 'use-package)
(use-package auto-compile
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+END_SRC

Install =delight= and =diminish=

#+BEGIN_SRC emacs-lisp
(use-package delight)
(use-package diminish)
(diminish 'auto-revert-mode)
#+END_SRC

Install =req-package=

#+BEGIN_SRC emacs-lisp
(use-package req-package
  :ensure t)
(require 'req-package)
#+END_SRC

Install the startup profiler

#+BEGIN_SRC emacs-lisp
  (use-package esup
    :ensure t)
#+END_SRC

Setup a splash screen

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :ensure t
  :diminish dashboard-mode
  :init
  (setq dashboard-banner-logo-title "Help, I'm stuck in this computer.")
  (setq dashboard-startup-banner 'logo)
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  (setq dashboard-items '((recents  . 5)
                        (bookmarks . 5)
                        (projects . 5)
                        (agenda . 5)
                        (registers . 5)))
  (dashboard-setup-startup-hook))
#+END_SRC

** General Configuration

#+BEGIN_SRC emacs-lisp
(use-package dash)
(add-to-list 'load-path "~/.emacs.d/site-lisp")
#+END_SRC

*** Backups

By default, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

Disk space is cheap. Save lots.

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

;;(desktop-save-mode-off)
;;(setq desktop-load-locked-desktop nil)
(savehist-mode 1)
(add-to-list 'savehist-additional-variables 'kill-ring)

(setq save-place-file "~/.emacs.d/saveplace") ;; keep my ~/ clean
(setq-default save-place t)

;; Configuration for bookmarks
(setq
  bookmark-default-file "~/.emacs.d/bookmarks" ;; keep my ~/ clean
  bookmark-save-flag 1);; autosave each change)
#+END_SRC

*** Theming

Remove useless clutter

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(toggle-scroll-bar -1) 
(setq inhibit-startup-screen t)
(setq ring-bell-function 'ignore)
(fset 'yes-or-no-p 'y-or-n-p)
(global-unset-key (kbd "C-x C-c"))
#+END_SRC

Set theme and welcome message

#+BEGIN_SRC emacs-lisp
;(use-package zenburn-theme :ensure zenburn-theme)
;(load-theme 'zenburn t)

;(use-package moe-theme)
;(moe-dark)

(use-package doom-themes)
(load-theme 'doom-one t)
(doom-themes-treemacs-config)
(doom-themes-org-config)

(global-linum-mode 0)

(setq initial-scratch-message ";;; Welcome back, master. Happy hacking.")
#+END_SRC

Sort out fonts. Use Fira Code with ligatures. The whole chunk at the end is the glyph mapping

#+BEGIN_SRC emacs-lisp
(set-default-font "-CTDB-Fira Code-normal-normal-normal-*-14-*-*-*-m-0-iso10646-1")
(setq default-frame-alist '((font . "Fira Code")))
(set-face-attribute 'bold nil :family "Fira Code"
					:height 110
					:weight 'bold)

;; Code points for ligatures
(set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
(set-fontset-font "fontset-default" '(#Xe100 . #Xe16f) "Fira Code Symbol")
(setq prettify-symbols-unprettify-at-point 'right-edge)


(defconst ligatures-fira-code-start #Xe100)

(defconst ligatures-fira-code-list
  '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
    "{-" "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
    "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
    "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
    ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
    "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
    "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
    "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
    ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
    "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
    "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
    "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
    "x" ":" "+" "+" "*")
  "Ordered ligatures for Fira Code font")

(defun ligatures-correct-symbol-bounds (len char)
  "Prepend up to LEN non-breaking spaces with reference points to CHAR.
This way `compose-region' called by function `prettify-symbols-mode'
will use the correct width of the symbols instead of the width
measured by `char-width'."
  (let ((acc (list char)))
    (while (> len 1)
      (setq acc (cons #X00a0 (cons '(Br . Bl) acc)))
      (setq len (1- len)))
    acc))


(defun ligatures-make-alist (ligatures starting-code)
  "Construct text to ligature character.
For each string in LIGATURES list add replacement from STARTING-CODE
sequentially."
  (mapcar (lambda (l)
            (let ((n starting-code))
              (setq starting-code (1+ starting-code))
              (when l
                (cons l (ligatures-correct-symbol-bounds
                         (length l) n)))))
          ligatures))

(defun ligatures-fira-code-setup ()
  "Add Fira Code ligatures to `prettify-symbols-alist'."
  (setq prettify-symbols-alist (append (ligatures-make-alist
                                        ligatures-fira-code-list
                                        ligatures-fira-code-start)
				       prettify-symbols-alist)))
(ligatures-fira-code-setup)
(global-prettify-symbols-mode 1)
(global-prettify-symbols-mode)
#+END_SRC

*** Modeline configuration

#+BEGIN_SRC emacs-lisp
  (use-package ein :ensure t)
  (use-package all-the-icons 
    :ensure t)
  (use-package all-the-icons-dired
    :ensure t
    :init
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

  (use-package quelpa :ensure t)
  (quelpa
    '(quelpa-use-package
     :fetcher git
     :url "https://framagit.org/steckerhalter/quelpa-use-package.git"))
  (require 'quelpa-use-package)
  (use-package font-lock+
    :quelpa
    (font-lock+ :repo "emacsmirror/font-lock-plus" :fetcher github))
  (require 'font-lock+)


  (use-package spaceline-all-the-icons :ensure t)
  (use-package nyan-mode :ensure t)
  (use-package anzu :ensure t)
  (use-package flycheck :ensure t)
  (use-package spaceline
    ;;;; :require ein all-the-icons spaceline-all-the-icons nyan-mode anzu evil flycheck
    :ensure t
    :demand
    :config
    (setq nyan-wavy-trail t)
    (nyan-mode t)
    (setq powerline-default-separator 'butt)
    (setq anzu-cons-mode-line-p nil)
    ;; Uncomment for evil mode (TODO: actually learn how to use evil mode)
    ;; (evil-mode 1)
    ;; (setq evil-default-state 'emacs)

    (require 'all-the-icons)
    (require 'spaceline-config)
    (require 'spaceline-segments)
    (setq inhibit-compacting-font-caches t)

    ;; Custom faces for vc-mode
    (defgroup +doom-modeline nil
      ""
      :group 'doom)
  
    (defface doom-modeline-info
      `((t (:inherit (success bold))))
      "Face for info-level messages in the modeline. Used by `*vc'."
      :group '+doom-modeline)
  
    (defface doom-modeline-warning
      `((t (:inherit (warning bold))))
      "Face for warnings in the modeline. Used by `*flycheck'"
      :group '+doom-modeline)

    (defface doom-modeline-urgent
      `((t (:inherit (error bold))))
      "Face for errors in the modeline. Used by `*flycheck'"
      :group '+doom-modeline)

    (spaceline-define-segment my/vc-line
      "My version control information with git icons."
      (powerline-raw
       (when (and vc-mode buffer-file-name)
	 (let* ((backend (vc-backend buffer-file-name))
		(state   (vc-state buffer-file-name backend)))
	   (let ((face    'mode-line-inactive)
		 (all-the-icons-default-adjust -0.1))
	     (concat "  "
		     (cond ((memq state '(edited added))
			    (setq face 'doom-modeline-info)
			    (all-the-icons-octicon
			     "git-compare"
			     :face face
			     :v-adjust -0.05))
			   ((eq state 'needs-merge)
			    (setq face 'doom-modeline-info)
			    (all-the-icons-octicon "git-merge" :face face))
			   ((eq state 'needs-update)
			    (setq face 'doom-modeline-warning)
			    (all-the-icons-octicon "arrow-down" :face face))
			   ((memq state '(removed conflict unregistered))
			    (setq face 'doom-modeline-urgent)
			    (all-the-icons-octicon "alert" :face face))
			   (t
			    (setq face 'font-lock-doc-face)
			    (all-the-icons-octicon
			     "git-compare"
			     :face face
			     :v-adjust -0.05)))
		     " "
                     (propertize (substring vc-mode (+ (if (eq backend 'Hg) 2 3) 2))
                     'face (if active face))
		     " "))))))

    (defun my/spaceline--theme (left second-left &rest additional-segments)
      "Convenience function for the spacemacs and emacs themes."
      (spaceline-compile
	`(,left
	  (anzu :prioritpy 4)
	  auto-compile
	  ,second-left
	  major-mode
	  (process :when active)
	  ((flycheck-error flycheck-warning flycheck-info)
	   :when active
	   :priority 10)
	  ;;(minor-modes :when active)
	  (mu4e-alert-segment :when active)
	  (erc-track :when active)
	  (my/vc-line :when active
	  :priority 10)
	  (org-pomodoro :when active)
	  (org-clock :when active)
	  (nyan-cat :priority -1))
	`(which-function
	  (python-pyvenv :fallback python-pyenv)
	  purpose
	  (battery :when active)
	  (selection-info :priority 2)
	  input-method
	  ((point-position
	    line-column)
	   :priority 8)
	  (global :when active)
	  ,@additional-segments
	  (hud :priority 8)))

      (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main)))))

    (defun my/spaceline-spacemacs-theme (&rest additional-segments)
      "Install the modeline used by Spacemacs.
  ADDITIONAL-SEGMENTS are inserted on the right, between `global' and
  `buffer-position'."
      (apply 'my/spaceline--theme
	     '((persp-name
		workspace-number
		window-number)
	       :fallback evil-state
	       :face highlight-face
	       :priority -1)
	     '((buffer-modified buffer-id remote-host)
	       :priority 8)
	     additional-segments))
    (my/spaceline-spacemacs-theme)
    (which-function-mode))
#+END_SRC

*** Sentences end with a single space

In my world, sentences end with a single space. This makes
sentence navigation commands work for me.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

*** Change "yes or no" to "y or n"

Lazy people like me never want to type "yes" when "y" will suffice.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Minibuffer editing - more space!

Sometimes you want to be able to do fancy things with the text
that you're entering into the minibuffer. Sometimes you just want
to be able to read it, especially when it comes to lots of text.
This binds =C-M-e= in a minibuffer so that you can edit the
contents of the minibuffer before submitting it.

#+BEGIN_SRC emacs-lisp
(use-package miniedit
  :ensure t
  :commands minibuffer-edit
  :init (miniedit-install))
#+END_SRC

*** Use cheat-sheets to remember commands
#+BEGIN_SRC emacs-lisp
(use-package cheatsheet
  :bind (("C-h x" . cheatsheet-show)))
#+END_SRC
*** Undo tree mode - visualize your undos and branches

People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.
This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp :drill:
(use-package undo-tree
  :diminish
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))
  :bind (("C-z" . undo-tree-undo)
		 ("C-S-z" . undo-tree-redo)))
#+END_SRC

*** Help - which-key and discover-my-major

It's hard to remember keyboard shortcuts. The =which-key= package pops up help after a short delay.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode))
#+END_SRC

Use this to see the key bindings in a mode

#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major
    :ensure t
    :bind (("C-h C-m" . discover-my-major)
           ("C-h M-m" . discover-my-mode)))
#+END_SRC

*** Killing text

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el
Determine scope for next invocation of =kill-region= or
=kill-ring-save=: When called interactively with no active
region, operate on a single line. Otherwise, operate on region.

#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (list (line-beginning-position)
        (line-beginning-position 2)))))
#+END_SRC

*** Ido mode
Never turn this off
#+BEGIN_SRC emacs-lisp
(ido-mode 1)
(setq ido-enable-flex-matching t)
(setq ido-everywhere t)
#+END_SRC

*** Under X, killing and yanking uses the X clipboard rather than just the primary selection
#+BEGIN_SRC emacs-lisp
 (setq save-interprogram-paste-before-kill t)
#+END_SRC
*** Smoother scrolling

#+BEGIN_SRC emacs-lisp
;; scroll one line at a time (less "jumpy" than defaults)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time

(setq scroll-preserve-screen-position t) ;; Make point remain "in place"
#+END_SRC

*** Highlight matching parents

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

*** Truncate lines by default
#+BEGIN_SRC emacs-lisp
(set-default 'truncate-lines t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

*** Highlight cursor when screen moves
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :delight
    :init
    (beacon-mode 1))
#+END_SRC

*** `M-/` bound to `hippie-expand`
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC


** Navigation
*** Tabs to switch buffers

Use Ctrl+Tab and Shift+Ctrl+Tab to switch buffers like in Firefox. TODO: This conflicts sometimes with Org mode opening headers and similar.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-tab>") 'next-buffer)
(global-set-key (kbd "<C-S-tab>") 'previous-buffer)
#+END_SRC

*** Pop to mark

Handy way of getting back to previous places.

#+BEGIN_SRC emacs-lisp
(bind-key "C-x p" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** Windmove - switching between windows

Windmove lets you move between windows with something more natural than cycling through =C-x o= (=other-window=).
Windmove doesn't behave well with Org, so we need to use different keybindings. (The letters are basically WASD on the right hand, but on Colemak)

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :bind
  (("<f2> i" . windmove-right)
   ("<f2> n" . windmove-left)
   ("<f2> u" . windmove-up)
   ("<f2> e" . windmove-down)
   ))
#+END_SRC

*** Save list of recently accessed files

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :ensure t
  :init
  (recentf-mode 1)
  (setq delete-old-versions t)
  (setq recentf-max-menu-items 30)
  (run-at-time nil (* 5 60) 'recentf-save-list)
  :bind (("C-x C-r" . recentf-open-files)))
#+END_SRC

*** Smartscan

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el, this makes =M-n= and =M-p= look for the symbol at point.

#+BEGIN_SRC emacs-lisp
(use-package smartscan
  :ensure t
  :config (global-smartscan-mode t))
#+END_SRC

*** IBuffer
Use IBuffer with =C-x C-b= to better organize current buffers
#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :ensure t
  :config
  (progn
	(setq ibuffer-saved-filter-groups
		  (quote (("default"
				   ("emacs" (or
							 (name . "^\\*scratch\\*$")
							 (name . "^\\*Messages\\*$")))
				   ("Org" ;; all org-related buffers
					(mode . org-mode))
				   ("Mail"
					(or  ;; mail-related buffers
					 (mode . message-mode)
					 (mode . mail-mode)
					 ;; etc.; all your mail related modes
					 ))
				   ("Programming" ;; prog stuff not already in MyProjectX
					(or
					 (mode . c-mode)
					 (mode . perl-mode)
					 (mode . python-mode)
					 (mode . emacs-lisp-mode)
					 (mode . haskell-mode)
					 ;; etc
					 ))
				   ("ERC"   (mode . erc-mode))))))
	(add-hook 'ibuffer-mode-hook
			  (lambda ()
				(ibuffer-switch-to-saved-filter-groups "default"))))
  :bind ("C-x C-b" . ibuffer))
#+END_SRC

*** Open line and open line above like in Vim
=C-o= opens the next line, =M-o= opens the previous line.
#+BEGIN_SRC emacs-lisp
;; Behave like vi's o command
(defun open-next-line (arg)
  "Move to the next line and then opens a line.
    See also `newline-and-indent'."
  (interactive "p")
  (end-of-line)
  (open-line arg)
  (forward-line 1)
  (when newline-and-indent
    (indent-according-to-mode)))
(global-set-key (kbd "C-o") 'open-next-line)

;; Behave like vi's O command
(defun open-previous-line (arg)
  "Open a new line before the current one.
     See also `newline-and-indent'."
  (interactive "p")
  (beginning-of-line)
  (open-line arg)
  (when newline-and-indent
    (indent-according-to-mode)))
(global-set-key (kbd "C-S-o") 'open-previous-line)
#+END_SRC

*** Use ace-window to navigate windows
#+BEGIN_SRC emacs-lisp
(require 'ace-window)
(global-set-key (kbd "M-o") 'ace-window)
(setq aw-keys '(?a ?r ?s ?t ?n ?e ?i ?o))
#+END_SRC

*** Highlight symbol like Vim's "*"

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :ensure t
  :diminish
  :bind (("C-*" . highlight-symbol-next)
		 ("C-x *" . highlight-symbol-prev)))
#+END_SRC

*** `zap-up-to-char` instead of `zap-to-char` bound to `M-z`
#+BEGIN_SRC emacs-lisp
  (autoload 'zap-up-to-char "misc"
    "Kill up to, but not including ARGth occurrence of CHAR." t)

  (global-set-key (kbd "M-z") 'zap-up-to-char)
#+END_SRC


** Org-mode
*** Modules
Org has a whole bunch of optional modules. These are the ones I'm
currently experimenting with.

#+BEGIN_SRC emacs-lisp :drill:
(setq org-modules '(org-bbdb
                      org-gnus
                      org-drill
                      org-info
                      org-jsinfo
                      org-habit
                      org-irc
                      org-mouse
                      org-protocol
                      org-annotate-file
                      org-eval
                      org-expiry
                      org-interactive-query
                      org-man
                      org-collector
                      org-panel
                      org-screen
                      org-toc))
(eval-after-load 'org
 '(org-load-modules-maybe t))
;; Prepare stuff for org-export-backends
(setq org-export-backends '(org latex icalendar html ascii))
(setq org-goto-interface 'outline-path-completion
      org-goto-max-level 10)
#+END_SRC


Useful template to insert elisp code blocks:

#+BEGIN_SRC emacs-lisp
;; add <el for emacs-lisp expansion
(eval-after-load 'org
  '(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>")))
#+END_SRC

*** Keyboard shortcuts

#+BEGIN_SRC emacs-lisp
(bind-key "C-c r" 'org-capture)
(bind-key "C-c a" 'org-agenda)
(bind-key "C-c l" 'org-store-link)
(bind-key "C-c L" 'org-insert-link-global)
(bind-key "C-c O" 'org-open-at-point-global)
(bind-key "<f9> <f9>" 'org-agenda-list)
(bind-key "<f9> <f8>" (lambda () (interactive) (org-capture nil "r")))
#+END_SRC

=append-next-kill= is more useful to me than =org-table-copy-region=.

*** Org-ref

#+BEGIN_SRC emacs-lisp
  (use-package org-ref
    :ensure t
    :init
    (setq org-ref-bibliography-notes "~/bibliography/notes.org"
	  org-ref-default-bibliography '("~/bibliography/references.bib")
	  org-ref-pdf-directory "~/bibliography/bibtex-pdfs/"))
#+END_SRC

*** Interleave-mode
#+BEGIN_SRC emacs-lisp
  (use-package interleave
    :ensure t)
#+END_SRC

*** Calibre-mode
#+BEGIN_SRC emacs-lisp
(require 'calibre-mode)
#+END_SRC

* Programming

Some general stuff. Setup outline mode so we can use heading levels for code navigation and organization.

#+BEGIN_SRC emacs-lisp
(use-package outshine
  :ensure t
  :diminish
  :init
  (outshine-mode))

;; Enables outline-minor-mode for *ALL* programming buffers
(add-hook 'prog-mode-hook 'outline-minor-mode)
#+END_SRC

*** Smartparens

Use smartparens to automatically open and close pairs of parens and quotes. But not "'" (single quote) because this is often used in identifiers in Haskell.

Opening curly braces in C++ also opens newline and indents.

Use =sp-cheat-sheet= for an overview of commands.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish smartparens-mode
    :init (smartparens-global-mode t)
    :config
    (progn
      (require 'smartparens-config)
      ;;;;;;;;;;;;;;;;;;;
      ;; keybinding management

      (define-key smartparens-mode-map (kbd "C-c s r n") 'sp-narrow-to-sexp)
      (define-key smartparens-mode-map (kbd "C-M-f") 'sp-forward-sexp)
      (define-key smartparens-mode-map (kbd "C-M-b") 'sp-backward-sexp)
      (define-key smartparens-mode-map (kbd "C-M-d") 'sp-down-sexp)
      (define-key smartparens-mode-map (kbd "C-M-a") 'sp-backward-down-sexp)
      (define-key smartparens-mode-map (kbd "C-S-a") 'sp-beginning-of-sexp)
      (define-key smartparens-mode-map (kbd "C-S-d") 'sp-end-of-sexp)

      (define-key smartparens-mode-map (kbd "C-M-e") 'sp-up-sexp)
      (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
      (define-key smartparens-mode-map (kbd "C-M-u") 'sp-backward-up-sexp)
      (define-key smartparens-mode-map (kbd "C-M-t") 'sp-transpose-sexp)

      (define-key smartparens-mode-map (kbd "C-M-n") 'sp-next-sexp)
      (define-key smartparens-mode-map (kbd "C-M-p") 'sp-previous-sexp)

      (define-key smartparens-mode-map (kbd "C-M-k") 'sp-kill-sexp)
      (define-key smartparens-mode-map (kbd "C-M-w") 'sp-copy-sexp)

      (define-key smartparens-mode-map (kbd "M-<delete>") 'sp-unwrap-sexp)
      (define-key smartparens-mode-map (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

      (define-key smartparens-mode-map (kbd "C-<right>") 'sp-forward-slurp-sexp)
      (define-key smartparens-mode-map (kbd "C-<left>") 'sp-forward-barf-sexp)
      (define-key smartparens-mode-map (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
      (define-key smartparens-mode-map (kbd "C-M-<right>") 'sp-backward-barf-sexp)

      (define-key smartparens-mode-map (kbd "M-D") 'sp-splice-sexp)
      (define-key smartparens-mode-map (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
      (define-key smartparens-mode-map (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
      (define-key smartparens-mode-map (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)

      (define-key smartparens-mode-map (kbd "C-]") 'sp-select-next-thing-exchange)
      (define-key smartparens-mode-map (kbd "C-<left_bracket>") 'sp-select-previous-thing)
      (define-key smartparens-mode-map (kbd "C-M-]") 'sp-select-next-thing)

      (define-key smartparens-mode-map (kbd "M-F") 'sp-forward-symbol)
      (define-key smartparens-mode-map (kbd "M-B") 'sp-backward-symbol)

      (define-key smartparens-mode-map (kbd "C-c s t") 'sp-prefix-tag-object)
      (define-key smartparens-mode-map (kbd "C-c s p") 'sp-prefix-pair-object)
      (define-key smartparens-mode-map (kbd "C-c s c") 'sp-convolute-sexp)
      (define-key smartparens-mode-map (kbd "C-c s a") 'sp-absorb-sexp)
      (define-key smartparens-mode-map (kbd "C-c s e") 'sp-emit-sexp)
      (define-key smartparens-mode-map (kbd "C-c s p") 'sp-add-to-previous-sexp)
      (define-key smartparens-mode-map (kbd "C-c s n") 'sp-add-to-next-sexp)
      (define-key smartparens-mode-map (kbd "C-c s j") 'sp-join-sexp)
      (define-key smartparens-mode-map (kbd "C-c s s") 'sp-split-sexp)))

  (sp-local-pair 'c++-mode "{" nil :post-handlers '((my/create-newline-and-enter-sexp "RET")))
  (defun my/create-newline-and-enter-sexp (&rest _ignored)
    "Open a new brace or bracket expression, with relevant newlines and indent. "
    (newline)
    (indent-according-to-mode)
    (forward-line -1)
    (indent-according-to-mode))
#+END_SRC

*** Company and Flycheck

 Setup =company= and =flycheck= for code completion.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :diminish
    :init (add-hook 'after-init-hook 'global-company-mode))

  (use-package flycheck
    :ensure t
    :after fringe-helper
    :diminish
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode)
    :config
    (progn
      (global-flycheck-mode t)
      ;; because git-gutter is in the left fringe
      (setq flycheck-indication-mode 'right-fringe)
      ;; A non-descript, left-pointing arrow
      (fringe-helper-define 'flycheck-fringe-bitmap-double-arrow 'center
        "...X...."
        "..XX...."
        ".XXX...."
        "XXXX...."
        ".XXX...."
        "..XX...."
        "...X....")))
#+END_SRC

Always indent new lines

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC

*** Git

Magit is magical for source control

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :init
  (autoload 'magit-status "magit" nil t)
  :bind ("C-x g" . magit-status))

(use-package magithub
  :after magit
  :config
  (magithub-feature-autoinject t)
  (setq magithub-clone-default-directory "~/Proggy"))
#+END_SRC

Show git statuses on the gutter

#+BEGIN_SRC emacs-lisp
(use-package fringe-helper
    :ensure t)

(use-package git-gutter-fringe+
    :ensure t
    :delight git-gutter+-mode
    :config
    (progn
      (global-git-gutter+-mode)
      (git-gutter+-enable-fringe-display-mode)
      ;; places the git gutter outside the margins.
      (setq-default fringes-outside-margins t)
      ;; Set not-so-bright colours
      (set-face-foreground 'git-gutter-fr+-modified "goldenrod1")
      (set-face-foreground 'git-gutter-fr+-added    "chartreuse3")
      (set-face-foreground 'git-gutter-fr+-deleted  "firebrick")
      ;; thin fringe bitmaps
      (fringe-helper-define 'git-gutter-fr+-added '(center repeated)
                            "XXX.....")
      (fringe-helper-define 'git-gutter-fr+-modified '(center repeated)
                            "XXX.....")
      (fringe-helper-define 'git-gutter-fr+-deleted 'bottom
                            "X......."
                            "XX......"
                            "XXX....."
                            "XXXX....")))
#+END_SRC

*** Projectile

Use =Projectile= for project management. Start with =C-c p=

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :delight '(:eval (concat " " (projectile-project-name)))
  :init
  (progn
    (setq projectile-keymap-prefix (kbd "C-c p"))
    (setq projectile-completion-system 'default)
    (setq projectile-enable-caching t)
    (projectile-global-mode))
  :config
  (setq projectile-mode-line '(:eval (format "[%s]" (projectile-project-name)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(cheatsheet-add-group 'Projectile
                      '(:key "C-c p p" :description "Switch project")
                      '(:key "C-c p f" :description "Find file in project")
                      '(:key "C-c p b" :description "Find buffer in project")

                      '(:key "C-c p a" :description "Switch to similar file (ext)")

                      '(:key "C-c p j" :description "Find tag in project")
                      '(:key "C-c p o" :description "Multi-occur in project")
                      '(:key "C-c p r" :description "Replace in project")
                      '(:key "C-c p t" :description "Toggle between test and impl")

                      '(:key "C-c p O a" :description "Open project agenda")

                      '(:key "C-c p s g" :description "Grep in project")
                      '(:key "C-c p s i" :description "Git grep in project")
                      '(:key "C-c p s r" :description "Ripgrep in project")

                      '(:key "C-c p u" :description "Run project")
                      '(:key "C-c p C" :description "Configure project")
                      '(:key "C-c p c" :description "Build project")
                      '(:key "C-c p P" :description "Test project"))
#+END_SRC

*** Perspective

Use =Perspective= for workspaces. A workspace is called a perspective. Commands are prefixed by =C-x x=:
- =s= -- persp-switch: Query a perspective to switch or create
- =k= -- persp-remove-buffer: Query a buffer to remove from current perspective
- =c= -- persp-kill : Query a perspective to kill
- =r= -- persp-rename: Rename current perspective
- =a= -- persp-add-buffer: Query an open buffer to add to current perspective
- =A= -- persp-set-buffer: Add buffer to current perspective and remove it from all others
- =i= -- persp-import: Import a given perspective from another frame.
- =n=, <right> -- persp-next : Switch to next perspective
- =p=, <left> -- persp-prev: Switch to previous perspective

The important ones are probably s, a, n, and p.

#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :diminish
  :init
  (persp-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp

(cheatsheet-add-group 'Perspective
                      '(:key "C-x x s" :description "Switch perspective")
                      '(:key "C-x x k" :description "Remove from current perspective")
                      '(:key "C-x x c" :description "Kill perspective")
                      '(:key "C-x x r" :description "Rename current perspective")
                      '(:key "C-x x a" :description "Add to current perspective")
                      '(:key "C-x x A" :description "Add to current perspective and remove from all others")
                      '(:key "C-x x n" :description "Next perspective")
                      '(:key "C-x x p" :description "Prev perspective"))
#+END_SRC

*** Ivy

Use =Ivy= instead of =Helm=. Interesting key-bindings:
- =C-c g= -- find file in current git repository
- =C-c j= -- grep in current git respository

#+BEGIN_SRC emacs-lisp

(use-package counsel
  :ensure t)

(use-package counsel-projectile
  :ensure t)

(use-package counsel-spotify
  :ensure t)
 
(use-package avy
  :ensure t)

(use-package ivy 
  :ensure t
  :delight
  :bind
  (("C-'" . ivy-avy)
   ("C-s" . swiper)
   ("M-x" . counsel-M-x)
   ("C-x C-f" . counsel-find-file)
   ("C-c g" . counsel-git)
   ("C-c j" . counsel-git-grep)
   ("C-c k" . counsel-ag)
   ("C-x l" . counsel-locate))
  :config
  (ivy-mode 1)
  ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
  (setq ivy-use-virtual-buffers t)
  ;; number of result lines to display
  (setq ivy-height 15)
  ;; does not count candidates
  (setq ivy-count-format "")
  ;; no regexp by default
  (setq ivy-initial-inputs-alist nil)
  ;; configure regexp engine.
  (setq ivy-re-builders-alist
	;; allow input not in order
        '((t   . ivy--regex-ignore-order)))
  (setq magit-completing-read-function 'ivy-completing-read)
  (counsel-projectile-mode))
#+END_SRC

*** Treemacs

From https://github.com/Alexander-Miller/treemacs. This is a sidebar/navigator that integrates with =Projectile=. For advanced layout, you need both git and python3. Use =C-c tn= or =<f8>= to start/show/go to treemacs. With projectile, use =C-c tt=.
When in treemacs, use =n/p= to move, =M-n/M-p= to move to same-height neighbour =u= to go to parent, and =C-n/C-k= to move between projects.
Experiment using =C-p= for project administration (TODO).

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :config
    (progn
      (setq treemacs-follow-after-init          t
	    treemacs-width                      28
	    treemacs-indentation                2
	    treemacs-collapse-dirs              (if (executable-find "python") 3 0)
	    treemacs-silent-refresh             nil
	    treemacs-change-root-without-asking nil
	    treemacs-sorting                    'alphabetic-desc
	    treemacs-show-hidden-files          t
	    treemacs-never-persist              nil
	    treemacs-is-never-other-window      nil
	    treemacs-goto-tag-strategy          'refetch-index)

      (treemacs-follow-mode t)
      ;;(treemacs-tag-follow-mode t)
      (setq treemacs-tag-follow-delay 1.0)
      (treemacs-filewatch-mode t)
      (treemacs-git-mode 'extended))
    :bind
    (:map global-map
	  ([f8]         . treemacs-toggle)
	  ("M-0"        . treemacs-select-window)
	  ("C-c 1"      . treemacs-delete-other-windows)
	  ("C-c tn"     . treemacs)
	  ("C-c tB"     . treemacs-bookmark)
	  ("C-c t f"  . treemacs-find-file)
	  ("C-c t M-t"  . treemacs-find-tag)))
#+END_SRC

Use treemacs constrained to the projectile project.

#+BEGIN_SRC emacs-lisp
  (use-package treemacs)
  (use-package projectile)
  (use-package treemacs-projectile
    ;; :require treemacs projectile
    :ensure t
    :config
    (setq treemacs-header-function #'treemacs-projectile-create-header)
    :bind (:map global-map
		("C-c tt" . treemacs-projectile)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(cheatsheet-add-group 'Treemacs
                      '(:key "C-c t t" :description "Treemacs projectile")
                      '(:key "C-c t f" :description "Find file")
                      '(:key "C-c t B" :description "Find bookmark"))
#+END_SRC

** C and Family

It offers (based on [[https://github.com/hlissner/doom-emacs/tree/master/modules/lang/cc][=Doom=]] emacs)

- Code completion (=company-irony=)
- eldoc support (=irony-eldoc=)
- Syntax-checking (=flycheck-irony=)
- Code navigation (=rtags=)
- File Templates (=c-mode, c++-mode=)
- Snippets (=cc-mode, c-mode, c++-mode=)
- Several improvements to C++11 indentation and syntax highlighting

It requires having =rtags= and =irony-server= installed.

Many tools will require you to have a =compilation database= (i.e. a =compile_commands.json= file).
If you use CMake, run it with =-DCMAKE_EXPORT_COMPILE_COMMANDS=ON .=, otherwise, use the cool BEAR tool, for example =bear make=.

*** Style

Set indentation style to the One True Style (Kernighan & Ritchie). Also, indentation with tabs. This is the objectively better option and everyone else is wrong (but spaces for alignment).

#+BEGIN_SRC
(setq c-auto-newline 1) ;; auto newline after curly, semicolon, etc
(setq-default c-default-style "k&r"
			  tab-width 4
			  c-basic-offset 4)
(setq guess-offset-quiet-p t)
#+END_SRC

Show the name of the function where you're located.

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
  (lambda ()
    (which-function-mode t)))
#+END_SRC

Use c-likes for editing =glsl= files. Also add the correct file extensions to c++ mode.
#+BEGIN_SRC emacs-lisp
  (use-package glsl-mode
    :ensure t
    :init
    (add-to-list 'auto-mode-alist '("\\.vert\\'" . glsl-mode))
    (add-to-list 'auto-mode-alist '("\\.frag\\'" . glsl-mode))
    (add-to-list 'auto-mode-alist '("\\.tesc\\'" . glsl-mode))
    (add-to-list 'auto-mode-alist '("\\.tese\\'" . glsl-mode)))

  (setq auto-mode-alist (cons '("\.cl$" . c-mode) auto-mode-alist))

  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.hpp\\'" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.cpp\\'" . c++-mode))
#+END_SRC

Highlight FIXME, TODO, etc

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
               (lambda ()
                (font-lock-add-keywords nil
                 '(("\\<\\(FIXME\\|TODO\\|BUG\\)" 1 font-lock-warning-face t)))))
#+END_SRC

Try mucking about with layout and style (TODO).

#+BEGIN_SRC emacs-lisp
    ;; C/C++ style settings
  (use-package cc-mode
    :config
    (c-toggle-electric-state -1)
    (c-toggle-auto-newline -1)
    (c-set-offset 'substatement-open '0) ; don't indent brackets
    (c-set-offset 'inline-open       '+)
    (c-set-offset 'block-open        '+)
    (c-set-offset 'brace-list-open   '+)
    (c-set-offset 'case-label        '+)
    (c-set-offset 'access-label      '-)
    (c-set-offset 'arglist-intro     '+)
    (c-set-offset 'arglist-close     '0)
    ;; Indent privacy keywords at same level as class properties
    ;; (c-set-offset 'inclass #'+cc-c-lineup-inclass)
    )

  (use-package modern-cpp-font-lock
    :ensure t
    :init
    (add-hook 'c++-mode-hook #'modern-c++-font-lock-mode))

#+END_SRC

*** RTags

Install from the package manager or from here https://github.com/Andersbakken/rtags
You need a running =rdm= server, which should start automatically, or do it with

#+BEGIN_SRC bash :tangle no
rdm &
rc -J $PROJECT_ROOT  # loads PROJECT_ROOT's compile_commands.json
#+END_SRC

Mostly use =M-.= to jump to symbol.

#+BEGIN_SRC emacs-lisp
  (use-package rtags
    :ensure t
    :init
    (add-hook 'c-mode-hook 'rtags-start-process-unless-running)
    (add-hook 'c++-mode-hook 'rtags-start-process-unless-running)
    :config
    (setq rtags-autostart-diagnostics t
          rtags-use-bookmarks nil
          rtags-completions-enabled nil
          ;; If not using ivy or helm to view results, use a pop-up window rather
          ;; than displaying it in the current window...
          rtags-results-buffer-other-window t
          ;; ...and don't auto-jump to first match before making a selection.
          rtags-jump-to-first-match nil))
#+END_SRC

Use =ivy= to browse the tags.

#+BEGIN_SRC emacs-lisp
(use-package ivy)
(use-package rtags)
(use-package ivy-rtags
    :ensure t
    ;; :require ivy rtags
    :config
    (setq rtags-display-result-backend 'ivy))
#+END_SRC

*** Irony

=irony-mode= is an Emacs minor-mode that aims at improving the editing experience for the C, C++ and Objective-C languages.
On the first run, =irony-mode= will ask you to build and install =irony-server=. To do so, type =M-x irony-install-server= RET.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-irony)
  (use-package company-irony)
  (use-package irony-eldoc)
  (use-package irony
    :ensure t
    ;; :require flycheck-irony company-irony irony-eldoc
    :diminish
    :commands irony-install-server
    :init
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'objc-mode-hook 'irony-mode)

    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

    ;; Company completion
    (eval-after-load 'company
      '(add-to-list 'company-backends 'company-irony))

    ;; Checker with flycheck
    (eval-after-load 'flycheck
      '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup)))
#+END_SRC

*** Convenience

Switch between header and source files with =C-c o= and compile with =C-c b=.

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
  (lambda()
    (local-set-key  (kbd "C-c o") 'ff-find-other-file)
     (local-set-key  (kbd "C-c b") 'compile)))
#+END_SRC

** Python

Use elpy with flycheck, ein, and jedi. These executables will probably have to be installed separately by the system package manager. Run =elpy-config= to set paths and other stuff.

#+BEGIN_SRC emacs-lisp
(use-package flycheck)
(use-package py-autopep8)
(use-package ein)
(use-package jedi)
(use-package elpy
  :ensure t
  ;; :require flycheck py-autopep8 ein jedi
  :diminish elpy-mode
  :diminish highlight-indentation-mode
  :config
  (elpy-enable)
  (setq python-shell-interpreter "ipython"
      python-shell-interpreter-args "-i --simple-prompt")
  (setq elpy-syntax-check-command "pylint")
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode)
  (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
  (setq elpy-rpc-backend "jedi"))
#+END_SRC

** Lisp and Family

Enable =paredit= (structural editing, like slurping and stuff).

#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :diminish
    :init
    (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
    (add-hook 'scheme-mode-hook 'enable-paredit-mode)

    (add-hook 'lisp-mode-hook 'enable-paredit-mode)
    (add-hook 'lisp-interation-hook 'enable-paredit-mode)

    (add-hook 'inferior-scheme-mode-hook 'enable-paredit-mode))
#+END_SRC

*** Common Lisp

Use the Steel Bank compiler. Be sure to check if the executable is installed and if it's in the PATH.

#+BEGIN_SRC emacs-lisp
(setq inferior-lisp-program "sbcl")
#+END_SRC

Use Slime for the actual editing.

#+BEGIN_SRC emacs-lisp

(use-package slime
  :ensure t
  :config
  (progn
    (add-hook 'lisp-mode-hook (lambda () (slime-mode t)))
    (add-hook 'lisp-mode-hook
	      (lambda ()
		(set (make-local-variable 'lisp-indent-function)
		     'common-lisp-indent-function)
		(sp-pair "`" nil :actions :rem)))
    (add-hook 'inferior-lisp-mode-hook (lambda () (inferior-slime-mode t)))
    (slime-setup)
    (slime-setup '(slime-fancy slime-asdf slime-banner))
    (setq slime-complete-symbol*-fancy t)
    (setq slime-complete-symbol-function 'slime-fuzzy-complete-symbol)))
#+END_SRC

*** Clojure

Use clojure with Cider.

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode-extra-font-locking)
(use-package cider)
(use-package paredit)
(use-package clojure-mode
  :ensure t
  ;; :require clojure-mode-extra-font-locking cider paredit
;;  :mode ("\\.edn$" "\\.boot$" "\\.cljs.*$" ("lein.env" . enh-ruby-mode))
  :config
  (progn
	(add-hook 'clojure-mode-hook 'paredit-mode)
	(add-hook 'clojure-mode-hook 'subword-mode)
	;; A little more syntax highlighting
	(require 'clojure-mode-extra-font-locking)))
#+END_SRC

Configure Cider

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure t
    :init
    ;; provides minibuffer documentation for the code you're typing into the repl
    (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
    ;; go right to the REPL buffer when it's finished connecting
    (setq cider-repl-pop-to-buffer-on-connect t)

    ;; When there's a cider error, show its buffer and switch to it
    (setq cider-show-error-buffer t)
    (setq cider-auto-select-error-buffer t)

    ;; Where to store the cider history.
    (setq cider-repl-history-file "~/.emacs.d/cider-history")

    ;; Wrap when navigating history.
    (setq cider-repl-wrap-history t)

    ;; enable paredit in your REPL
    (add-hook 'cider-repl-mode-hook 'paredit-mode)

    (defun cider-refresh ()
      (interactive)
      (cider-interactive-eval (format "(user/reset)")))

    (defun cider-user-ns ()
      (interactive)
      (cider-repl-set-ns "user"))

    (eval-after-load 'cider
      '(progn
         (define-key clojure-mode-map (kbd "C-M-r") 'cider-refresh)
         (define-key clojure-mode-map (kbd "C-c u") 'cider-user-ns)
         (define-key cider-mode-map (kbd "C-c u") 'cider-user-ns))))
#+END_SRC

** OCaml

Syntax highlighting, REPL, and debugging are provided by Tuareg. We do have to make sure that =opam= is installed.

#+BEGIN_SRC emacs-lisp
(use-package tuareg
  :ensure t
  :diminish
  :init
  (progn
	(add-hook 'tuareg-mode-hook 'tuareg-imenu-set-imenu)
	(setq auto-mode-alist
		  (append '(("\\.ml[ily]?$" . tuareg-mode)
					("\\.topml$" . tuareg-mode))
				  auto-mode-alist))
	(autoload 'utop-setup-ocaml-buffer "utop" "Toplevel for OCaml" t)
	(add-hook 'tuareg-mode-hook 'utop-setup-ocaml-buffer)))
#+END_SRC

Other facilities like code completion are handled by Merlin.

#+BEGIN_SRC emacs-lisp
(use-package merlin
  :ensure t
  :diminish
  :config
  (progn
	(setq opam-share (substring (shell-command-to-string "opam config var share") 0 -1))
	(add-to-list 'load-path (concat opam-share "/emacs/site-lisp"))

	;; Enable Merlin for ML buffers
	(add-hook 'tuareg-mode-hook 'merlin-mode)
	(setq merlin-use-auto-complete-mode t)
	(setq merlin-error-after-save nil)

	(define-key merlin-mode-map
	  (kbd "C-c <up>") 'merlin-type-enclosing-go-up)
	(define-key merlin-mode-map
	  (kbd "C-c <down>") 'merlin-type-enclosing-go-down)
	(set-face-background 'merlin-type-face "#88FF44")))

;; -- enable auto-complete -------------------------------
;; Not required, but useful along with merlin-mode
(use-package auto-complete
  :ensure t
  :init
  (add-hook 'tuareg-mode-hook 'auto-complete-mode))

(use-package ocp-indent
  :defer t)

(setq opam-share (substring (shell-command-to-string "opam config var share") 0 -1))
#+END_SRC

** Latexes

Use AucTex (or however they capitalize it).

#+BEGIN_SRC emacs-lisp
(use-package auctex
  :disabled t
  :ensure t)

(unless (locate-library "auctex")
  (package-install 'auctex))
(load "auctex.el" nil t t)
#+END_SRC

Make Latex mode auto-save, view PDFs, and activate spellcheck. Also activate RefTex for bibliography insertion.

#+BEGIN_SRC emacs-lisp
(setq TeX-PDF-mode t)
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(add-hook 'LaTeX-mode-hook 'visual-line-mode)
(add-hook 'LaTeX-mode-hook 'flyspell-mode)
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)

(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
(setq reftex-plug-into-AUCTeX t)
#+END_SRC

Change reftex-var to markdown-pandoc format, so they can be parsed and converted by pandoc.
#+BEGIN_SRC emacs-lisp
  ;;TODO: do this more cleanly
  (use-package markdown-mode
    :ensure t
    :init
    (eval-after-load 'reftex-vars
      '(progn
         (setq reftex-cite-format '((?\C-m . "[@%l]")))))
    (add-hook 'markdown-mode-hook 'reftex-mode)
    (add-hook 'markdown-mode-hook 'flyspell-mode))
#+END_SRC

** Haskell

Use intero for the editing. TODO: test again between intero, dante, ghc-mod, and such. TODONE: intero has hands down the best support for =stack=, which definitely should be used. I couldn't test =dante= extensively.
Also automatically run =haskell-mode-stylish-buffer= on save. Intero *requires* =stack= and =ghc-mod= (installed as executables in the PATH).

- Code completion (company-ghc)
- Look up documentation (hoogle)
- eldoc support (intero)
- REPL (ghci)
- Syntax-checking (flycheck)
- Code navigation (intero)

Useful keybindings:


|             |                                |                          |
|-------------+--------------------------------+--------------------------|
| =C-c ! l=   | flycheck-list-errors           | See a list of all errors |
| =C-c ! n/p= | flycheck-(next/previous)-error | Jump to next/prev error  |
| =M-.=       | intero-goto-definition         | Go to symbol definition  |
| =C-c C-t=   | intero-type-at                 | Show type at cursor      |
| =C-c C-r=   | intero-apply-suggestion        | Apply =GHC= suggestion   |
|             |                                |                          |

#+BEGIN_SRC emacs-lisp
(cheatsheet-add-group 'Haskell
                      '(:key "C-c ! l" :description "List errors")
                      '(:key "C-c ! n" :description "Jump to next error")

                      '(:key "M-." :description "Go to symbol definition")
                      '(:key "C-c C-t" :description "Show type at cursor")
                      '(:key "C-u C-c C-t" :description "Insert type of thing at cursor")
                      '(:key "C-c C-i" :description "Show inof of thing at point")
                      '(:key "C-c C-r" :description "Apply suggestion"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package w3m)
  (use-package haskell-mode
    :mode "\\.hs$"
    :mode ("\\.ghci$" . ghci-script-mode)
    :mode ("\\.cabal$" . haskell-cabal-mode)
    :interpreter (("runghc" . haskell-mode)
                  ("runhaskell" . haskell-mode))
    :config
    (load "haskell-mode-autoloads" nil t)
    (autoload 'switch-to-haskell "inf-haskell" nil t)
    (add-hook 'haskell-mode-hook 'haskell-auto-insert-module-template))
#+END_SRC

Setup intero:

#+BEGIN_SRC emacs-lisp
  (use-package intero
    :ensure t
    :hook (haskell-mode . intero-mode)
    :diminish
    :config
    (intero-global-mode 1)
    (add-hook 'haskell-mode-hook
              (lambda ()
                (add-hook 'before-save-hook 'haskell-mode-stylish-buffer nil 'make-it-local)))
    ;(add-hook 'intero-mode-hook #'(flycheck-mode eldoc-mode))
    (setq haskell-process-args-cabal-repl (quote ("--ghc-option=-ferror-spans")))
    ;(haskell-process-auto-import-loaded-modules t)
    (haskell-process-log t)
    ;(haskell-process-suggest-hoogle-imports t)
    (haskell-process-suggest-remove-import-lines t)
    (haskell-process-type (quote cabal-repl))
    (haskell-tags-on-save t))

  (use-package hindent
    :ensure t
    :hook (haskell-mode . hindent-mode))
#+END_SRC

Company for completion:

#+BEGIN_SRC emacs-lisp
  (use-package company-ghc
    :ensure t
    ;; :require haskell-mode company
    :after haskell-mode
    :diminish
    :init
    (add-hook 'haskell-mode-hook 'ghc-comp-init)

    (setq company-ghc-show-info 'oneline))
#+END_SRC
** Rust

Rust support to Emacs.

- Code completion (=racer=)
- Syntax checking (=flycheck=)
- Eldoc support (=go-eldoc=)
- Snippets

=racer= is required, so make sure it's installed!

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :ensure t
  :mode "\\.rs$")
#+END_SRC

Setup racer, flycheck and company:

#+BEGIN_SRC emacs-lisp
(use-package rust-mode)
(use-package racer
    :ensure t
    ;; :require rust-mode
    :diminish
    :after rust-mode
    :hook (rust-mode . racer-mode)
    :config
    (setenv "PATH" (concat (getenv "PATH") (substitute-in-file-name ":$HOME/.cargo/bin/")))
    (add-to-list 'exec-path (substitute-in-file-name "$HOME/.cargo/bin/"))

    (add-hook 'rust-mode-hook #'eldoc-mode)

    (setq racer-cmd (executable-find "racer")
          racer-rust-src-path (or (getenv "RUST_SRC_PATH")
                                  (expand-file-name "rust/src/" (substitute-in-file-name "$HOME/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/"))))

    (unless (file-exists-p racer-cmd)
      (warn "rust-mode: racer binary can't be found; auto-completion is disabled")))


(use-package company)
(use-package company-racer
    :ensure t
    ;; :require company
    :after racer
    :config
    (with-eval-after-load 'company
      (add-to-list 'company-backends 'company-racer)))


(use-package flycheck)
(use-package flycheck-rust
    :ensure t
    ;; :require flycheck
    :after rust-mode
    :hook (flycheck-mode . flycheck-rust-setup)
    :config (add-hook 'rust-mode-hook #'flycheck-mode))
#+END_SRC



* Bookend

** Resolve dependency graph, download, and install.
#+BEGIN_SRC emacs-lisp
  (require 'git-gutter-fringe+)
  (require 'racer)
  (require 'ivy)
  (require 'company-racer)
  (require 'flycheck-rust)
  (require 'treemacs-projectile)
  (require 'ivy-rtags)
  (require 'irony)
  (require 'elpy)
  (require 'clojure-mode)
  (require 'company-ghc)
  (require 'spaceline)
  (req-package-finish)

  (toggle-scroll-bar -1)

  ;; Remove pesky scroll bars
  (when (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))

  (add-hook 'after-make-frame-functions #'(lambda (frame)
					    (scroll-bar-mode -1)))
#+END_SRC
