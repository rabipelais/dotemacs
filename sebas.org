#+TITLE: Sebas Emacs configuration
#+OPTIONS: toc:4 h:4
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle sebas.el
#+PROPERTY: tangle sebas.el

* Configuration
** About this file
   :PROPERTIES:
   :CUSTOM_ID: babel-init
   :END:
<<babel-init>>

This is my attempt at making a literate Emacs config file.
To actually produce/extract the elisp code, run =M-x org-babel-tangle= (=C-c C-v t=).

** Meta

All changes to the configuration should be done in =init.org=, *not* in
=init.el=. Any changes in the =init.el= will be overwritten by saving
=init.org=. The =init.el= in this repo should not be tracked by git, and
is replaced the first time Emacs is started (assuming it has been renamed
to =~/.emacs.d=).

Emacs can't load =.org=-files directly, but =org-mode= provides functions
to extract the code blocks and write them to a file. There are multiple
ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
could just use =org-babel-load-file=, but I had problems with
byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
but the git commits got a little messy. So here is a new approach.

When this configuration is loaded for the first time, the ~init.el~ is
the file that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
;; This file replaces itself with the actual configuration at first run.

;; We can't tangle without org!
(require 'org)
;; Open the configuration
(find-file (concat user-emacs-directory "init.org"))
;; tangle it
(org-babel-tangle)
;; load it
(load-file (concat user-emacs-directory "init.el"))
;; finally byte-compile it
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

It tangles the org-file, so that this file is overwritten with the actual
configuration.

There is no reason to track the =init.el= that is generated; by running
the following command =git= will not bother tracking it:

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If one wishes to make changes to the repo-version of =init.el= start
tracking again with:

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

The =init.el= should (after the first run) mirror the source blocks in
the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
extracts the code blocks from the current file into a source-specific
file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to
the =after-save-hook= ensuring to always tangle and byte-compile the
=org=-document after changes.

#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "If the current buffer is 'init.org' the code-blocks are
tangled, and the tangled file is compiled."
  (when (equal (buffer-file-name)
               (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle)
      (byte-compile-file (concat user-emacs-directory "init.el")))))

(add-hook 'after-save-hook 'tangle-init)
#+END_SRC


** Startup

#+BEGIN_SRC emacs-lisp
;; This sets up the load path so that we can override it
(package-initialize)
(setq use-package-always-ensure t)
(add-to-list 'load-path "/usr/share/emacs/25.2/lisp/cedet")
#+END_SRC

Install, start up and configure =use-package=, really useful for loading packages lazily

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(setq use-package-verbose t)
(setq use-package-always-ensure t)
(require 'use-package)
(use-package auto-compile
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+END_SRC

** General Configuration

#+BEGIN_SRC emacs-lisp
(use-package dash)
#+END_SRC

*** Backups

By default, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

Disk space is cheap. Save lots.

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

(desktop-save-mode 1)
(savehist-mode 1)
(add-to-list 'savehist-additional-variables 'kill-ring)
#+END_SRC

*** Theming

Remove useless clutter

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(setq inhibit-startup-screen t)
#+END_SRC

Set theme and welcome message

#+BEGIN_SRC emacs-lisp
(use-package zenburn :ensure zenburn-theme)
(load-theme 'zenburn t)

(global-linum-mode 1)

(setq initial-scratch-message ";;; Welcome back, master. Happy hacking.")
#+END_SRC

Sort out fonts. Use Fira Code with ligatures. The whole chunk at the end is the glyph mapping

#+BEGIN_SRC emacs-lisp
(set-default-font "-CTDB-Fira Code-normal-normal-normal-*-14-*-*-*-m-0-iso10646-1")
(setq default-frame-alist '((font . "Fira Code")))
(set-face-attribute 'bold nil :family "Fira Code"
					:height 110
					:weight 'bold)

;; Code points for ligatures
(set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
(set-fontset-font "fontset-default" '(#Xe100 . #Xe16f) "Fira Code Symbol")
(setq prettify-symbols-unprettify-at-point 'right-edge)
#+END_SRC

*** Modeline configuration

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :ensure ein
    :ensure all-the-icons
    :ensure spaceline-all-the-icons
    ;; Super necessary nyan cat progress bar
    :ensure nyan-mode
    ;; Display search information in the modeline
    :ensure anzu
    :ensure evil
    :ensure flycheck
    :config
    (setq nyan-wavy-trail t)
    (nyan-mode t)
    (setq powerline-default-separator 'butt)
    (setq anzu-cons-mode-line-p nil)
    ;; Uncomment for evil mode (TODO: actually learn how to use evil mode)
    ;; (evil-mode 1)
    ;; (setq evil-default-state 'emacs)
    (require 'spaceline-config)
    (require 'spaceline-segments)
    (defun my/spaceline--theme (left second-left &rest additional-segments)
      "Convenience function for the spacemacs and emacs themes."
      (spaceline-compile
        `(,left
          (anzu :priority 4)
          auto-compile
          ,second-left
          major-mode
          (process :when active)
          ((flycheck-error flycheck-warning flycheck-info)
           :when active
           :priority -9)
          (minor-modes :when active)
          (mu4e-alert-segment :when active)
          (erc-track :when active)
          (version-control :when active
                           :priority 7)
          (org-pomodoro :when active)
          (org-clock :when active)
          nyan-cat)
        `(which-function
          (python-pyvenv :fallback python-pyenv)
          purpose
          (battery :when active)
          (selection-info :priority 2)
          input-method
          ((point-position
            line-column)
           :priority -10)
          (global :when active)
          ,@additional-segments
          (hud :priority -10)))

      (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main)))))

    (defun my/spaceline-spacemacs-theme (&rest additional-segments)
      "Install the modeline used by Spacemacs.
  ADDITIONAL-SEGMENTS are inserted on the right, between `global' and
  `buffer-position'."
      (apply 'my/spaceline--theme
             '((persp-name
                workspace-number
                window-number)
               :fallback evil-state
               :face highlight-face
               :priority -10)
             '((buffer-modified buffer-id remote-host)
               :priority -10)
             additional-segments))
    (my/spaceline-spacemacs-theme)
    (which-function-mode))
#+END_SRC

*** Sentences end with a single space

In my world, sentences end with a single space. This makes
sentence navigation commands work for me.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

*** Change "yes or no" to "y or n"

Lazy people like me never want to type "yes" when "y" will suffice.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Minibuffer editing - more space!

Sometimes you want to be able to do fancy things with the text
that you're entering into the minibuffer. Sometimes you just want
to be able to read it, especially when it comes to lots of text.
This binds =C-M-e= in a minibuffer so that you can edit the
contents of the minibuffer before submitting it.

#+BEGIN_SRC emacs-lisp
(use-package miniedit
  :commands minibuffer-edit
  :init (miniedit-install))
#+END_SRC
*** Undo tree mode - visualize your undos and branches

People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.
This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp :drill:
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+END_SRC

*** Help - guide-key

It's hard to remember keyboard shortcuts. The =guide-key= package pops up help after a short delay.

#+BEGIN_SRC emacs-lisp
(use-package guide-key
  :defer t
  :diminish guide-key-mode
  :config
  (progn
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  (guide-key-mode 1)))  ; Enable guide-key-mode
#+END_SRC

*** Killing text

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el
Determine scope for next invocation of =kill-region= or
=kill-ring-save=: When called interactively with no active
region, operate on a single line. Otherwise, operate on region.

#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (list (line-beginning-position)
        (line-beginning-position 2)))))
#+END_SRC

** Navigation
*** Pop to mark

Handy way of getting back to previous places.

#+BEGIN_SRC emacs-lisp
(bind-key "C-x p" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** Windmove - switching between windows

Windmove lets you move between windows with something more natural than cycling through =C-x o= (=other-window=).
Windmove doesn't behave well with Org, so we need to use different keybindings. (The letters are basically WASD on the right hand, but on Colemak)

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :bind
  (("<f2> i" . windmove-right)
   ("<f2> n" . windmove-left)
   ("<f2> u" . windmove-up)
   ("<f2> e" . windmove-down)
   ))
#+END_SRC

*** Save list of recently accessed files

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :defer t
  :ensure t
  :init
  (recentf-mode 1)
  (setq recentf-max-saved-items 200)
  (setq recentf-max-menu-items 30)
  (run-at-time nil (* 5 60) 'recentf-save-list)
  :bind (("C-x C-r" . recentf-open-files)))
#+END_SRC

*** Smartscan

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el, this makes =M-n= and =M-p= look for the symbol at point.

#+BEGIN_SRC emacs-lisp
(use-package smartscan
  :defer t
  :config (global-smartscan-mode t))
#+END_SRC
