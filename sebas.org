#+TITLE: Sebas Emacs configuration
#+OPTIONS: toc:4 h:4
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle sebas.el
#+PROPERTY: tangle sebas.el

* General Configuration
** About this file
   :PROPERTIES:
   :CUSTOM_ID: babel-init
   :END:
<<babel-init>>

This is my attempt at making a literate Emacs config file.
To actually produce/extract the elisp code, run =M-x org-babel-tangle= (=C-c C-v t=).

** Meta

All changes to the configuration should be done in =init.org=, *not* in
=init.el=. Any changes in the =init.el= will be overwritten by saving
=init.org=. The =init.el= in this repo should not be tracked by git, and
is replaced the first time Emacs is started (assuming it has been renamed
to =~/.emacs.d=).

Emacs can't load =.org=-files directly, but =org-mode= provides functions
to extract the code blocks and write them to a file. There are multiple
ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
could just use =org-babel-load-file=, but I had problems with
byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
but the git commits got a little messy. So here is a new approach.

When this configuration is loaded for the first time, the ~init.el~ is
the file that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
;; This file replaces itself with the actual configuration at first run.

;; We can't tangle without org!
(require 'org)
;; Open the configuration
(find-file (concat user-emacs-directory "init.org"))
;; tangle it
(org-babel-tangle)
;; load it
(load-file (concat user-emacs-directory "init.el"))
;; finally byte-compile it
(byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

It tangles the org-file, so that this file is overwritten with the actual
configuration.

There is no reason to track the =init.el= that is generated; by running
the following command =git= will not bother tracking it:

#+BEGIN_SRC sh :tangle no
git update-index --assume-unchanged init.el
#+END_SRC

If one wishes to make changes to the repo-version of =init.el= start
tracking again with:

#+BEGIN_SRC sh :tangle no
git update-index --no-assume-unchanged init.el
#+END_SRC

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
;;; -*- lexical-binding: t -*-
#+END_SRC

The =init.el= should (after the first run) mirror the source blocks in
the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
extracts the code blocks from the current file into a source-specific
file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to
the =after-save-hook= ensuring to always tangle and byte-compile the
=org=-document after changes.

#+BEGIN_SRC emacs-lisp
(defun tangle-init ()
  "If the current buffer is 'init.org' the code-blocks are
tangled, and the tangled file is compiled."
  (when (equal (buffer-file-name)
               (expand-file-name (concat user-emacs-directory "init.org")))
    ;; Avoid running hooks when tangling.
    (let ((prog-mode-hook nil))
      (org-babel-tangle)
      (byte-compile-file (concat user-emacs-directory "init.el")))))

(add-hook 'after-save-hook 'tangle-init)
#+END_SRC


** Startup

#+BEGIN_SRC emacs-lisp
;; This sets up the load path so that we can override it
(package-initialize)
(setq use-package-always-ensure t)
(add-to-list 'load-path "/usr/share/emacs/25.2/lisp/cedet")
#+END_SRC

Install, start up and configure =use-package=, really useful for loading packages lazily

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(setq use-package-verbose t)
(setq use-package-always-ensure t)
(require 'use-package)
(use-package auto-compile
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+END_SRC

** General Configuration

#+BEGIN_SRC emacs-lisp
(use-package dash)
#+END_SRC

*** Backups

By default, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

Disk space is cheap. Save lots.

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

(desktop-save-mode 1)
(savehist-mode 1)
(add-to-list 'savehist-additional-variables 'kill-ring)
#+END_SRC

*** Theming

Remove useless clutter

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(setq inhibit-startup-screen t)
#+END_SRC

Set theme and welcome message

#+BEGIN_SRC emacs-lisp
(use-package zenburn :ensure zenburn-theme)
(load-theme 'zenburn t)

(global-linum-mode 1)

(setq initial-scratch-message ";;; Welcome back, master. Happy hacking.")
#+END_SRC

Sort out fonts. Use Fira Code with ligatures. The whole chunk at the end is the glyph mapping

#+BEGIN_SRC emacs-lisp
(set-default-font "-CTDB-Fira Code-normal-normal-normal-*-14-*-*-*-m-0-iso10646-1")
(setq default-frame-alist '((font . "Fira Code")))
(set-face-attribute 'bold nil :family "Fira Code"
					:height 110
					:weight 'bold)

;; Code points for ligatures
(set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
(set-fontset-font "fontset-default" '(#Xe100 . #Xe16f) "Fira Code Symbol")
(setq prettify-symbols-unprettify-at-point 'right-edge)
#+END_SRC

*** Modeline configuration

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :ensure ein
    :ensure all-the-icons
    :ensure spaceline-all-the-icons
    ;; Super necessary nyan cat progress bar
    :ensure nyan-mode
    ;; Display search information in the modeline
    :ensure anzu
    :ensure evil
    :ensure flycheck
    :config
    (setq nyan-wavy-trail t)
    (nyan-mode t)
    (setq powerline-default-separator 'butt)
    (setq anzu-cons-mode-line-p nil)
    ;; Uncomment for evil mode (TODO: actually learn how to use evil mode)
    ;; (evil-mode 1)
    ;; (setq evil-default-state 'emacs)
    (require 'spaceline-config)
    (require 'spaceline-segments)
    (defun my/spaceline--theme (left second-left &rest additional-segments)
      "Convenience function for the spacemacs and emacs themes."
      (spaceline-compile
        `(,left
          (anzu :priority 4)
          auto-compile
          ,second-left
          major-mode
          (process :when active)
          ((flycheck-error flycheck-warning flycheck-info)
           :when active
           :priority -9)
          (minor-modes :when active)
          (mu4e-alert-segment :when active)
          (erc-track :when active)
          (version-control :when active
                           :priority 7)
          (org-pomodoro :when active)
          (org-clock :when active)
          nyan-cat)
        `(which-function
          (python-pyvenv :fallback python-pyenv)
          purpose
          (battery :when active)
          (selection-info :priority 2)
          input-method
          ((point-position
            line-column)
           :priority -10)
          (global :when active)
          ,@additional-segments
          (hud :priority -10)))

      (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main)))))

    (defun my/spaceline-spacemacs-theme (&rest additional-segments)
      "Install the modeline used by Spacemacs.
  ADDITIONAL-SEGMENTS are inserted on the right, between `global' and
  `buffer-position'."
      (apply 'my/spaceline--theme
             '((persp-name
                workspace-number
                window-number)
               :fallback evil-state
               :face highlight-face
               :priority -10)
             '((buffer-modified buffer-id remote-host)
               :priority -10)
             additional-segments))
    (my/spaceline-spacemacs-theme)
    (which-function-mode))
#+END_SRC

*** Sentences end with a single space

In my world, sentences end with a single space. This makes
sentence navigation commands work for me.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

*** Change "yes or no" to "y or n"

Lazy people like me never want to type "yes" when "y" will suffice.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Minibuffer editing - more space!

Sometimes you want to be able to do fancy things with the text
that you're entering into the minibuffer. Sometimes you just want
to be able to read it, especially when it comes to lots of text.
This binds =C-M-e= in a minibuffer so that you can edit the
contents of the minibuffer before submitting it.

#+BEGIN_SRC emacs-lisp
(use-package miniedit
  :commands minibuffer-edit
  :init (miniedit-install))
#+END_SRC
*** Undo tree mode - visualize your undos and branches

People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.
This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp :drill:
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+END_SRC

*** Help - guide-key

It's hard to remember keyboard shortcuts. The =guide-key= package pops up help after a short delay.

#+BEGIN_SRC emacs-lisp
(use-package guide-key
  :defer t
  :diminish guide-key-mode
  :config
  (progn
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  (guide-key-mode 1)))  ; Enable guide-key-mode
#+END_SRC

*** Killing text

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el
Determine scope for next invocation of =kill-region= or
=kill-ring-save=: When called interactively with no active
region, operate on a single line. Otherwise, operate on region.

#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (list (line-beginning-position)
        (line-beginning-position 2)))))
#+END_SRC

** Navigation
*** Pop to mark

Handy way of getting back to previous places.

#+BEGIN_SRC emacs-lisp
(bind-key "C-x p" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** Windmove - switching between windows

Windmove lets you move between windows with something more natural than cycling through =C-x o= (=other-window=).
Windmove doesn't behave well with Org, so we need to use different keybindings. (The letters are basically WASD on the right hand, but on Colemak)

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :bind
  (("<f2> i" . windmove-right)
   ("<f2> n" . windmove-left)
   ("<f2> u" . windmove-up)
   ("<f2> e" . windmove-down)
   ))
#+END_SRC

*** Save list of recently accessed files

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :defer t
  :ensure t
  :init
  (recentf-mode 1)
  (setq recentf-max-saved-items 200)
  (setq recentf-max-menu-items 30)
  (run-at-time nil (* 5 60) 'recentf-save-list)
  :bind (("C-x C-r" . recentf-open-files)))
#+END_SRC

*** Smartscan

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el, this makes =M-n= and =M-p= look for the symbol at point.

#+BEGIN_SRC emacs-lisp
(use-package smartscan
  :defer t
  :config (global-smartscan-mode t))
#+END_SRC

** Org-mode

*** Modules
Org has a whole bunch of optional modules. These are the ones I'm
currently experimenting with.

#+BEGIN_SRC emacs-lisp :drill:
(setq org-modules '(org-bbdb
                      org-gnus
                      org-drill
                      org-info
                      org-jsinfo
                      org-habit
                      org-irc
                      org-mouse
                      org-protocol
                      org-annotate-file
                      org-eval
                      org-expiry
                      org-interactive-query
                      org-man
                      org-collector
                      org-panel
                      org-screen
                      org-toc))
(eval-after-load 'org
 '(org-load-modules-maybe t))
;; Prepare stuff for org-export-backends
(setq org-export-backends '(org latex icalendar html ascii))
(setq org-goto-interface 'outline-path-completion
      org-goto-max-level 10)
#+END_SRC

*** Keyboard shortcuts

#+BEGIN_SRC emacs-lisp
(bind-key "C-c r" 'org-capture)
(bind-key "C-c a" 'org-agenda)
(bind-key "C-c l" 'org-store-link)
(bind-key "C-c L" 'org-insert-link-global)
(bind-key "C-c O" 'org-open-at-point-global)
(bind-key "<f9> <f9>" 'org-agenda-list)
(bind-key "<f9> <f8>" (lambda () (interactive) (org-capture nil "r")))
#+END_SRC

=append-next-kill= is more useful to me than =org-table-copy-region=.


* Programming

Some general stuff. Setup outline mode so we can use heading levels for code navigation and organization.

#+BEGIN_SRC emacs-lisp
(use-package outshine
  :ensure t
  :init
  (add-hook 'outline-minor-mode-hook 'outshine-hook-function))

;; Enables outline-minor-mode for *ALL* programming buffers
(add-hook 'prog-mode-hook 'outline-minor-mode)
#+END_SRC

Setup =company= and =flycheck= for code completion.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :init (add-hook 'after-init-hook 'global-company-mode))

(use-package flycheck
  :ensure t
  :diminish flycheck-mode
  :init
  (add-hook 'after-init-hook #'global-flycheck-mode))
#+END_SRC

Always indent new lines

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC

Magit is magical for source control

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :init
  (autoload 'magit-status "magit" nil t)
  :bind ("C-x g" . magit-status))
#+END_SRC

** C and Family

TODO: actually set up the C coding environment. I've never managed to get CEDET and stuff to work.

*** Style

Set indentation style to the One True Style (Kernighan & Ritchie). Also, indentation with tabs. This is the objectively better option and everyone else is wrong (but spaces for alignment).

#+BEGIN_SRC
(setq c-auto-newline 1) ;; auto newline after curly, semicolon, etc
(setq-default c-default-style "k&r"
			  tab-width 4
			  c-basic-offset 4)
(setq guess-offset-quiet-p t)
#+END_SRC

Show the name of the function where you're located.

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
  (lambda ()
    (which-function-mode t)))
#+END_SRC

Use c-likes for editing =glsl= files. Also add the correct file extensions to c++ mode.
#+BEGIN_SRC emacs-lisp
  (use-package glsl-mode
    :ensure t
    :defer t
    :init
    (add-to-list 'auto-mode-alist '("\\.vert\\'" . glsl-mode))
    (add-to-list 'auto-mode-alist '("\\.frag\\'" . glsl-mode))
    (add-to-list 'auto-mode-alist '("\\.tesc\\'" . glsl-mode))
    (add-to-list 'auto-mode-alist '("\\.tese\\'" . glsl-mode)))

  (setq auto-mode-alist (cons '("\.cl$" . c-mode) auto-mode-alist))

  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.hpp\\'" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.cpp\\'" . c++-mode))
#+END_SRC

Highlight FIXME, TODO, etc

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
               (lambda ()
                (font-lock-add-keywords nil
                 '(("\\<\\(FIXME\\|TODO\\|BUG\\)" 1 font-lock-warning-face t)))))
#+END_SRC

*** Convenience

Switch between header and source files with =C-c o= and compile with =C-c b=.

#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
  (lambda()
    (local-set-key  (kbd "C-c o") 'ff-find-other-file)
     (local-set-key  (kbd "C-c b") 'compile)))
#+END_SRC

** Python

Use elpy with flycheck, ein, and jedi. These executables will probably have to be installed separately by the system package manager. Run =elpy-config= to set paths and other stuff.

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :ensure flycheck
  :ensure py-autopep8
  :ensure ein
  :ensure jedi
  :diminish elpy-mode
  :diminish highlight-indentation-mode
  :config
  (elpy-enable)
  (elpy-use-ipython)
  (setq elpy-syntax-check-command "pylint")
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode)
  (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
  (setq elpy-rpc-backend "jedi"))
#+END_SRC

** Lisp and Family

Enable =paredit= (structural editing, like slurping and stuff).

#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :init
    (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
    (add-hook 'scheme-mode-hook 'enable-paredit-mode)

    (add-hook 'lisp-mode-hook 'enable-paredit-mode)
    (add-hook 'lisp-interation-hook 'enable-paredit-mode)

    (add-hook 'inferior-scheme-mode-hook 'enable-paredit-mode))
#+END_SRC

*** Common Lisp

Use the Steel Bank compiler. Be sure to check if the executable is installed and if it's in the PATH.

#+BEGIN_SRC emacs-lisp
(setq inferior-lisp-program "sbcl")
#+END_SRC

Use Slime for the actual editing.

#+BEGIN_SRC emacs-lisp

(use-package slime
  :ensure t
  :defer t
  :config
  (progn
    (add-hook 'lisp-mode-hook (lambda () (slime-mode t)))
    (add-hook 'lisp-mode-hook
	      (lambda ()
		(set (make-local-variable 'lisp-indent-function)
		     'common-lisp-indent-function)
		(sp-pair "`" nil :actions :rem)))
    (add-hook 'inferior-lisp-mode-hook (lambda () (inferior-slime-mode t)))
    (slime-setup)
    (slime-setup '(slime-fancy slime-asdf slime-banner))
    (setq slime-complete-symbol*-fancy t)
    (setq slime-complete-symbol-function 'slime-fuzzy-complete-symbol)))
#+END_SRC

*** Clojure

Use clojure with Cider.

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :ensure t
  :ensure clojure-mode-extra-font-locking
  :ensure cider
  :ensure paredit
  :defer t
;;  :mode ("\\.edn$" "\\.boot$" "\\.cljs.*$" ("lein.env" . enh-ruby-mode))
  :config
  (progn
	(add-hook 'clojure-mode-hook 'paredit-mode)
	(add-hook 'clojure-mode-hook 'subword-mode)
	;; A little more syntax highlighting
	(require 'clojure-mode-extra-font-locking)))
#+END_SRC

Configure Cider

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure t
    :init
    ;; provides minibuffer documentation for the code you're typing into the repl
    (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
    ;; go right to the REPL buffer when it's finished connecting
    (setq cider-repl-pop-to-buffer-on-connect t)

    ;; When there's a cider error, show its buffer and switch to it
    (setq cider-show-error-buffer t)
    (setq cider-auto-select-error-buffer t)

    ;; Where to store the cider history.
    (setq cider-repl-history-file "~/.emacs.d/cider-history")

    ;; Wrap when navigating history.
    (setq cider-repl-wrap-history t)

    ;; enable paredit in your REPL
    (add-hook 'cider-repl-mode-hook 'paredit-mode)

    (defun cider-refresh ()
      (interactive)
      (cider-interactive-eval (format "(user/reset)")))

    (defun cider-user-ns ()
      (interactive)
      (cider-repl-set-ns "user"))

    (eval-after-load 'cider
      '(progn
         (define-key clojure-mode-map (kbd "C-M-r") 'cider-refresh)
         (define-key clojure-mode-map (kbd "C-c u") 'cider-user-ns)
         (define-key cider-mode-map (kbd "C-c u") 'cider-user-ns))))
#+END_SRC

** OCaml

Syntax highlighting, REPL, and debugging are provided by Tuareg. We do have to make sure that =opam= is installed.

#+BEGIN_SRC emacs-lisp
(use-package tuareg
  :ensure t
  :defer t
  :init
  (progn
	(add-hook 'tuareg-mode-hook 'tuareg-imenu-set-imenu)
	(setq auto-mode-alist
		  (append '(("\\.ml[ily]?$" . tuareg-mode)
					("\\.topml$" . tuareg-mode))
				  auto-mode-alist))
	(autoload 'utop-setup-ocaml-buffer "utop" "Toplevel for OCaml" t)
	(add-hook 'tuareg-mode-hook 'utop-setup-ocaml-buffer)))
#+END_SRC

Other facilities like code completion are handled by Merlin.

#+BEGIN_SRC emacs-lisp
(use-package merlin
  :ensure t
  :defer t
  :config
  (progn
	(setq opam-share (substring (shell-command-to-string "opam config var share") 0 -1))
	(add-to-list 'load-path (concat opam-share "/emacs/site-lisp"))

	;; Enable Merlin for ML buffers
	(add-hook 'tuareg-mode-hook 'merlin-mode)
	(setq merlin-use-auto-complete-mode t)
	(setq merlin-error-after-save nil)

	(define-key merlin-mode-map
	  (kbd "C-c <up>") 'merlin-type-enclosing-go-up)
	(define-key merlin-mode-map
	  (kbd "C-c <down>") 'merlin-type-enclosing-go-down)
	(set-face-background 'merlin-type-face "#88FF44")))

;; -- enable auto-complete -------------------------------
;; Not required, but useful along with merlin-mode
(use-package auto-complete
  :ensure t
  :defer t
  :init
  (add-hook 'tuareg-mode-hook 'auto-complete-mode))

(use-package ocp-indent
  :ensure t
  :defer t)

(setq opam-share (substring (shell-command-to-string "opam config var share") 0 -1))
#+END_SRC
